<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8' />
  <title>02.06</title>
</head>
<body>
<div style='text-align: center'>
  <canvas id='canvas01' style='width: 1000px; height: 600px'></canvas>
</div>
<script>
  /*
   * 2.6. Compositing on the Canvas
   *     context.globalCompositeOperation
   */
  window.addEventListener(
    'load',
    function() {
      var canvas = document.getElementById('canvas01');
      if (canvas && canvas.getContext) {
        var ctx = (function(canvas) {
          var dpr = window.devicePixelRatio || 1;
          var rect = canvas.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          var ctx = canvas.getContext('2d');
          ctx.scale(dpr, dpr);
          return ctx;
        })(canvas);
        var width = canvas.width / (window.devicePixelRatio || 1);
        var height = canvas.height / (window.devicePixelRatio || 1);

        drawScreen(ctx, width, height);
      }

      /**
       * context.globalCompositeOperation 属性,
       * 用于设置新绘制的图形跟已绘制的图形, 在重叠时如何渲染,
       * 默认值为 source-over, 即在重叠部分新图形会覆盖旧图形.
       *
       * @param {CanvasRenderingContext2D} ctx
       * @param width
       * @param height
       */
      function drawScreen(ctx, width, height) {
        ctx.save();

        {
          // 网格背景
          ctx.lineWidth = 0.2;
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';

          for (var i = 0; i <= height / 50; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * 50);
            ctx.lineTo(width, i * 50);
            ctx.stroke();
          }

          for (var j = 0; j <= width / 50; j++) {
            ctx.beginPath();
            ctx.moveTo(j * 50, 0);
            ctx.lineTo(j * 50, height);
            ctx.stroke();
          }
        }

        ctx.beginPath();
        ctx.fillStyle = '#0000ff';
        ctx.fillRect(50, 50, 100, 100);

        ctx.globalCompositeOperation = 'source-over';

        ctx.beginPath();
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(100, 100, 100, 100);
      }
    },
    false,
  );
</script>
</body>
</html>
